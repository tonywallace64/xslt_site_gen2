<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html><xhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:exslt="http://exslt.org/strings">
  <xhtml:head>
    <xhtml:meta name="Keywords" content=""/>
    <xhtml:title>xslt</xhtml:title>
    <xhtml:meta name="viewport" content="width=device-width, initial-scale=1"/>
    <xhtml:style type="text/css">
	  body {color:blue;}  
	  p  {line-height=130%;}
	  h1 {text-align:center;}
	  h2 {text-align:center;}
	  h3 {text-align:center;}
	  pre { color:#800080;}
	  a:link {color:#0000FF;}
	  a:visited {color:#C0C000;}
	  nav {
	    background-image:url(images/grgcleft2.png);
	    position: absolute;
	    top :0px;
	    bottom:0;
	    left: 0;
	    width: 240px;
	    }
	 section {
	    position: relative;
	    margin-left: 250px;
	    }
	</xhtml:style>
  </xhtml:head>
  <xhtml:body>
    <xhtml:div id="navbar"/>
    <xhtml:section>
      <xhtml:a href="index.xhtml">
        <xhtml:img xmlns:xf="http://www.w3.org/2002/xforms" src="images/hw.png" left="250px" width="100%"/>
      </xhtml:a>
      <xhtml:br/>
      <xhtml:h2 xmlns:ax="abc">What is xslt?</xhtml:h2>
      <xhtml:p xmlns:ax="abc">XSLT is an XML language designed to convert XML documents to other XML formats,
expecially XSL-FO.
XSL-FO is a stylesheet language, often used for formatting documents
prior to conversion to PDF. It can be used to generate other formats and is useful to convert
arbitary XML documents into XHTML.</xhtml:p>
      <xhtml:h2 xmlns:ax="abc">Getting Started</xhtml:h2>
      <example xmlns:ax="abc">
<title>A simple XSLT stylesheet</title>
<ax:content>
<xhtml:pre>

&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:template match="text()"/&gt;
  &lt;xsl:template match='/site'&gt;
    &lt;xsl:for-each select="./pages/page"&gt;
      &lt;xsl:choose&gt;
	&lt;xsl:when test="ancestor::pages[navtype='mesh']"&gt;
	  Found
	&lt;/xsl:when&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;

</xhtml:pre>
<xhtml:p>The first line declares this XML to be an xslt stylesheet.  Note the use of the namespace.  The second line rule overrides default text node processing.  The default is to output text nodes.  This rule says do nothing. Note the match expressions on the &lt;xsl:template&gt; are xpath expressions.  The third line matches a root element "site". Inside this element this root element becomes the self() or current node.  On the next line the for-each iterates through each /site/pages/page node, each node in turn becoming the self node.  For each page having an ancestor pages element, containing an element navtype whose text value is "mesh", the value Found is output.  The reader should also note the test attribute of the when element is set to an xpath expression.   An empty nodeset is false.</xhtml:p>
</ax:content>
</example>
      <xhtml:p xmlns:ax="abc">The above example shows the interplay of xml technologies, XPATH, XSLT and 
XML Namespaces.  Once again it emphasises the need to grasp the basics such
as Namespaces and XPATH before moving onto other technologies such as XSLT.</xhtml:p>
      <xhtml:p xmlns:ax="abc">There is much more to XSLT than the simple example shown here, the reader
is asked to do check out some of the online tutorials and download the XSLT standard.</xhtml:p>
      <xhtml:h2 xmlns:ax="abc">XSLT processors</xhtml:h2>
      <xhtml:p xmlns:ax="abc">Many XSLT processors only process version 1.0 XSLT, which uses XPATH 1.0.  Support for this standard is however widespread.</xhtml:p>
      <xhtml:ul xmlns:ax="abc">
<xhtml:li><xhtml:p>Firefox supports XSLT 1.O.  To transform your document in the browser, insert a processing instruction such as &lt;?xml-stylesheet href="xsltforms/xsltforms.xsl" type="text/xsl"?&gt; at the top of the file.</xhtml:p></xhtml:li>
<xhtml:li><xhtml:p>The linux command xsltproc also support XSLT 1.0.</xhtml:p></xhtml:li>
</xhtml:ul>
    </xhtml:section>
    <xhtml:script>
//  test1
  function writeNavbar(Contents)
  {
  document.getElementById("navbar").innerHTML=Contents;
  };
  function httpGetAsync(theUrl, callback)
  {
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)
            callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", theUrl, true); // true for asynchronous 
    xmlHttp.send(null);
  };
  httpGetAsync(
//
  "main_nav.xml",writeNavbar);</xhtml:script>
  </xhtml:body>
</xhtml:html>
